import time
import logging
import sys
import json
import redis
from sqlalchemy import text
from database import SessionLocal
from exchange import exchange_manager
from config import settings
from models import Signal
import models
from strategies.rsi_strategy import RsiStrategy

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler(sys.stdout)]
)
logger = logging.getLogger(__name__)

# Redis Connection
try:
    redis_client = redis.from_url(settings.REDIS_URL)
    logger.info("Connected to Redis")
except Exception as e:
    logger.error(f"Failed to connect to Redis: {e}")
    redis_client = None

def handle_signal(signal_data):
    """
    Callback function to handle signals generated by strategies.
    1. Save to Database
    2. Publish to Redis
    """
    logger.info(f"Processing Signal: {signal_data}")
    
    # 1. Save to Database
    db = SessionLocal()
    try:
        signal = Signal(
            strategy_id=signal_data['strategy_id'],
            symbol=signal_data['symbol'],
            side=signal_data['side'],
            price=signal_data['price'],
            reason=signal_data['reason']
        )
        db.add(signal)
        db.commit()
        logger.info(f"Signal saved to DB: ID {signal.id}")
    except Exception as e:
        logger.error(f"Failed to save signal to DB: {e}")
    finally:
        db.close()

    # 2. Publish to Redis
    if redis_client:
        try:
            redis_client.publish('strategy_signals', json.dumps(signal_data))
            logger.info("Signal published to Redis channel 'strategy_signals'")
        except Exception as e:
            logger.error(f"Failed to publish signal to Redis: {e}")

def _start_strategy(s_db, running_strategies):
    try:
        config = json.loads(s_db.config_json)
        strategy = RsiStrategy(
            strategy_id=s_db.id,
            name=s_db.name,
            config=config,
            exchange=exchange_manager,
            signal_callback=handle_signal
        )
        strategy.start()
        running_strategies[s_db.id] = {
            'instance': strategy,
            'config_raw': s_db.config_json
        }
        logger.info(f"Started strategy: {s_db.name} (ID: {s_db.id})")
    except Exception as e:
        logger.error(f"Failed to start strategy {s_db.name}: {e}")

def main():
    logger.info("Strategy Engine Starting...")
    # 1. Test Database Connection
    try:
        db = SessionLocal()
        db.execute(text("SELECT 1"))
        logger.info("Database connection successful")
        db.close()
    except Exception as e:
        logger.error(f"Database connection failed: {e}")
        return.error(f"Database connection failed: {e}")
        return

    # 2. Test Exchange Connection
    if exchange_manager.exchange:
        logger.info("Exchange connection initialized")
    else:
        logger.warning("Exchange connection failed or not configured")

    running_strategies = {} # {id: {'instance': strategy_obj, 'config_raw': str}}

    # 4. Main Loop
    logger.info("Entering Main Loop...")
    while True:
        # --- Dynamic Strategy Loading ---
        try:
            db = SessionLocal()
            active_db_strategies = db.query(models.Strategy).filter(models.Strategy.is_active == True).all()
            
            active_ids = {s.id for s in active_db_strategies}
            current_ids = set(running_strategies.keys())

            # 1. Stop removed/deactivated strategies
            for s_id in current_ids - active_ids:
                logger.info(f"Strategy {s_id} deactivated or removed. Stopping...")
                running_strategies[s_id]['instance'].stop()
                del running_strategies[s_id]

            # 2. Start new or Update existing strategies
            for s_db in active_db_strategies:
                # Check if new
                if s_db.id not in running_strategies:
                    logger.info(f"Found new strategy: {s_db.name}")
                    _start_strategy(s_db, running_strategies)
                
                # Check if config changed
                elif running_strategies[s_db.id]['config_raw'] != s_db.config_json:
                    logger.info(f"Configuration changed for {s_db.name}. Restarting...")
                    running_strategies[s_db.id]['instance'].stop()
                    _start_strategy(s_db, running_strategies)
                    
        except Exception as e:
            logger.error(f"Error syncing strategies from DB: {e}")
        finally:
            db.close()

        if not running_strategies:
            logger.warning("No active strategies running.")

        # --- Run Logic ---
        for s_entry in running_strategies.values():
            try:
                s_entry['instance'].on_tick()
            except Exception as e:
                logger.error(f"Error in strategy tick: {e}")

        time.sleep(60) # Loop every minute

if __name__ == "__main__":
    main()
