import time
import logging
import sys
import json
import redis
from sqlalchemy import text
from database import SessionLocal
from exchange import exchange_manager
from config import settings
from models import Signal
import models
from strategies.rsi_strategy import RsiStrategy, set_cache_manager as set_rsi_cache_manager
from strategies.btc_5down_strategy import BtcFiveDownStrategy, set_cache_manager as set_btc_cache_manager
from concurrent.futures import ThreadPoolExecutor, as_completed
import threading
from functools import lru_cache

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler(sys.stdout)]
)
logger = logging.getLogger(__name__)

# ==================== ç¼“å­˜é…ç½® ====================
class CacheManager:
    """ç®¡ç†å„ç±»ç¼“å­˜ï¼Œå‡å°‘é‡å¤æ•°æ®è®¿é—®ï¼Œæ”¯æŒå¤šäº¤æ˜“æ‰€"""
    def __init__(self):
        # {exchange:symbol: data}  ä¾‹å¦‚: "binance:BTC/USDT": ohlcv_data
        self.market_data_cache = {}  
        self.strategy_config_cache = {}  # {strategy_id: config_dict}
        self.cache_ttl = {
            'market_data': 30,  # å¸‚åœºæ•°æ®ç¼“å­˜ 30 ç§’
            'strategy_config': 300,  # ç­–ç•¥é…ç½®ç¼“å­˜ 5 åˆ†é’Ÿ
        }
        self.last_cache_update = {
            'market_data': {},
            'strategy_config': {},
        }
    
    def _make_cache_key(self, exchange: str, symbol: str, timeframe: str = None):
        """ç”Ÿæˆç¼“å­˜é”®ï¼Œæ”¯æŒå¤šäº¤æ˜“æ‰€"""
        if timeframe:
            return f"{exchange}:{symbol}:{timeframe}"
        return f"{exchange}:{symbol}"
    
    def get_cache(self, cache_type: str, exchange: str, symbol: str, timeframe: str = None):
        """è·å–ç¼“å­˜ï¼Œå¦‚æœè¿‡æœŸåˆ™è¿”å›None"""
        if cache_type == 'market_data':
            cache = self.market_data_cache
            last_update = self.last_cache_update['market_data']
            ttl = self.cache_ttl['market_data']
            key = self._make_cache_key(exchange, symbol, timeframe)
        elif cache_type == 'strategy_config':
            cache = self.strategy_config_cache
            last_update = self.last_cache_update['strategy_config']
            ttl = self.cache_ttl['strategy_config']
            key = f"{exchange}:{symbol}" if exchange else symbol
        else:
            return None
        
        if key in cache:
            if time.time() - last_update.get(key, 0) < ttl:
                return cache[key]
            else:
                # ç¼“å­˜è¿‡æœŸï¼Œåˆ é™¤
                del cache[key]
                if key in last_update:
                    del last_update[key]
        
        return None
    
    def set_cache(self, cache_type: str, exchange: str, symbol: str, value, timeframe: str = None):
        """è®¾ç½®ç¼“å­˜"""
        if cache_type == 'market_data':
            cache = self.market_data_cache
            last_update = self.last_cache_update['market_data']
            key = self._make_cache_key(exchange, symbol, timeframe)
        elif cache_type == 'strategy_config':
            cache = self.strategy_config_cache
            last_update = self.last_cache_update['strategy_config']
            key = f"{exchange}:{symbol}" if exchange else symbol
        else:
            return
        
        cache[key] = value
        last_update[key] = time.time()
    
    def clear_expired(self):
        """æ¸…ç†è¿‡æœŸç¼“å­˜"""
        current_time = time.time()
        
        # æ¸…ç†å¸‚åœºæ•°æ®ç¼“å­˜
        for key in list(self.market_data_cache.keys()):
            if current_time - self.last_cache_update['market_data'].get(key, 0) >= self.cache_ttl['market_data']:
                del self.market_data_cache[key]
                if key in self.last_cache_update['market_data']:
                    del self.last_cache_update['market_data'][key]
        
        # æ¸…ç†ç­–ç•¥é…ç½®ç¼“å­˜
        for key in list(self.strategy_config_cache.keys()):
            if current_time - self.last_cache_update['strategy_config'].get(key, 0) >= self.cache_ttl['strategy_config']:
                del self.strategy_config_cache[key]
                if key in self.last_cache_update['strategy_config']:
                    del self.last_cache_update['strategy_config'][key]
    
    def get_cache_size(self):
        """è·å–ç¼“å­˜å¤§å°ç»Ÿè®¡"""
        return {
            'market_data': len(self.market_data_cache),
            'strategy_config': len(self.strategy_config_cache),
            'total': len(self.market_data_cache) + len(self.strategy_config_cache)
        }

cache_manager = CacheManager()

# Redis Connection
try:
    redis_client = redis.from_url(settings.REDIS_URL)
    logger.info("Connected to Redis")
except Exception as e:
    logger.error(f"Failed to connect to Redis: {e}")
    redis_client = None

def handle_signal(signal_data):
    """
    Callback function to handle signals generated by strategies.
    1. Save to Database
    2. Publish to Redis
    """
    logger.info(f"Processing Signal: {signal_data}")
    
    # 1. Save to Database
    db = SessionLocal()
    try:
        signal = Signal(
            strategy_id=signal_data['strategy_id'],
            symbol=signal_data['symbol'],
            side=signal_data['side'],
            price=signal_data['price'],
            reason=signal_data['reason']
        )
        db.add(signal)
        db.commit()
        logger.info(f"Signal saved to DB: ID {signal.id}")
    except Exception as e:
        logger.error(f"Failed to save signal to DB: {e}")
    finally:
        db.close()

    # 2. Publish to Redis
    if redis_client:
        try:
            redis_client.publish('strategy_signals', json.dumps(signal_data))
            logger.info("Signal published to Redis channel 'strategy_signals'")
        except Exception as e:
            logger.error(f"Failed to publish signal to Redis: {e}")

def _start_strategy(s_db, running_strategies):
    try:
        config = json.loads(s_db.config_json)
        
        # Map strategy names to classes
        strategy_classes = {
            'RSI Strategy': RsiStrategy,
            'BTC 5è¿é˜´ç­–ç•¥': BtcFiveDownStrategy,
            'btc_5down': BtcFiveDownStrategy,
        }
        
        # è·å–ç­–ç•¥ç±»ï¼Œé»˜è®¤ä½¿ç”¨ RsiStrategy
        strategy_class = strategy_classes.get(s_db.name, RsiStrategy)
        
        strategy = strategy_class(
            strategy_id=s_db.id,
            name=s_db.name,
            config=config,
            exchange=exchange_manager,
            signal_callback=handle_signal
        )
        
        # ä¸ºç­–ç•¥åˆå§‹åŒ–ç¼“å­˜ç®¡ç†å™¨
        if strategy_class == RsiStrategy:
            set_rsi_cache_manager(cache_manager)
        elif strategy_class == BtcFiveDownStrategy:
            set_btc_cache_manager(cache_manager)
        strategy.start()
        running_strategies[s_db.id] = {
            'instance': strategy,
            'config_raw': s_db.config_json
        }
        logger.info(f"Started strategy: {s_db.name} (ID: {s_db.id}) using {strategy_class.__name__}")
    except Exception as e:
        logger.error(f"Failed to start strategy {s_db.name}: {e}", exc_info=True)

def main():
    logger.info("Strategy Engine Starting...")
    # 1. Test Database Connection
    try:
        db = SessionLocal()
        db.execute(text("SELECT 1"))
        logger.info("Database connection successful")
        db.close()
    except Exception as e:
        logger.error(f"Database connection failed: {e}")
        return

    # 2. Test Exchange Connection
    if exchange_manager.exchange:
        logger.info("Exchange connection initialized")
    else:
        logger.warning("Exchange connection failed or not configured")

    running_strategies = {} # {id: {'instance': strategy_obj, 'config_raw': str}}

    # 4. Main Loop
    logger.info("Entering Main Loop...")
    loop_count = 0
    while True:
        loop_count += 1
        
        # å®šæœŸæ¸…ç†è¿‡æœŸç¼“å­˜ï¼ˆæ¯ 5 åˆ†é’Ÿæ¸…ç†ä¸€æ¬¡ï¼‰
        if loop_count % 5 == 0:
            cache_manager.clear_expired()
            cache_stats = cache_manager.get_cache_size()
            logger.info(f"ğŸ“Š Cache Stats - Market Data: {cache_stats['market_data']}, Strategy Config: {cache_stats['strategy_config']}, Total: {cache_stats['total']}")
        
        # --- Dynamic Strategy Loading ---
        try:
            db = SessionLocal()
            active_db_strategies = db.query(models.Strategy).filter(models.Strategy.is_active == True).all()
            
            active_ids = {s.id for s in active_db_strategies}
            current_ids = set(running_strategies.keys())

            # 1. Stop removed/deactivated strategies
            for s_id in current_ids - active_ids:
                logger.info(f"Strategy {s_id} deactivated or removed. Stopping...")
                running_strategies[s_id]['instance'].stop()
                del running_strategies[s_id]

            # 2. Start new or Update existing strategies
            for s_db in active_db_strategies:
                # Check if new
                if s_db.id not in running_strategies:
                    logger.info(f"Found new strategy: {s_db.name}")
                    _start_strategy(s_db, running_strategies)
                
                # Check if config changed
                elif running_strategies[s_db.id]['config_raw'] != s_db.config_json:
                    logger.info(f"Configuration changed for {s_db.name}. Restarting...")
                    running_strategies[s_db.id]['instance'].stop()
                    _start_strategy(s_db, running_strategies)
                    
        except Exception as e:
            logger.error(f"Error syncing strategies from DB: {e}")
        finally:
            db.close()

        if not running_strategies:
            logger.warning("No active strategies running.")

        # --- Run Logic (Parallel Execution) ---
        # ä½¿ç”¨çº¿ç¨‹æ± å¹¶å‘æ‰§è¡Œæ‰€æœ‰ç­–ç•¥ï¼Œé¿å…å•ä¸ªç­–ç•¥å¡ä½æ•´ä¸ªå¼•æ“
        with ThreadPoolExecutor(max_workers=min(len(running_strategies), 10)) as executor:
            futures = {}
            for strategy_id, s_entry in running_strategies.items():
                future = executor.submit(s_entry['instance'].on_tick)
                futures[future] = strategy_id
            
            # ç­‰å¾…æ‰€æœ‰ç­–ç•¥æ‰§è¡Œå®Œæˆï¼ˆè®¾ç½®è¶…æ—¶ï¼‰
            for future in as_completed(futures, timeout=50):
                strategy_id = futures[future]
                try:
                    future.result()
                except Exception as e:
                    logger.error(f"Error in strategy {strategy_id} tick: {e}")

        time.sleep(60) # Loop every minute

if __name__ == "__main__":
    main()
