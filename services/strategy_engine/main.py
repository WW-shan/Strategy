import time
import logging
import sys
import json
import redis
from sqlalchemy import text
from database import SessionLocal
from exchange import exchange_manager
from config import settings
from models import Signal
import models
from strategies.rsi_strategy import RsiStrategy
from strategies.btc_5down_strategy import BtcFiveDownStrategy
from concurrent.futures import ThreadPoolExecutor, as_completed
import threading
from functools import lru_cache

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler(sys.stdout)]
)
logger = logging.getLogger(__name__)

# ==================== 缓存配置 ====================
class CacheManager:
    """管理各类缓存，减少重复数据访问"""
    def __init__(self):
        self.market_data_cache = {}  # {symbol: {'price': float, 'timestamp': int}}
        self.strategy_config_cache = {}  # {strategy_id: config_dict}
        self.cache_ttl = {
            'market_data': 30,  # 市场数据缓存 30 秒
            'strategy_config': 300,  # 策略配置缓存 5 分钟
        }
        self.last_cache_update = {
            'market_data': {},
            'strategy_config': {},
        }
    
    def get_cache(self, cache_type: str, key: str):
        """获取缓存，如果过期则返回None"""
        if cache_type == 'market_data':
            cache = self.market_data_cache
            last_update = self.last_cache_update['market_data']
            ttl = self.cache_ttl['market_data']
        elif cache_type == 'strategy_config':
            cache = self.strategy_config_cache
            last_update = self.last_cache_update['strategy_config']
            ttl = self.cache_ttl['strategy_config']
        else:
            return None
        
        if key in cache:
            if time.time() - last_update.get(key, 0) < ttl:
                return cache[key]
            else:
                # 缓存过期，删除
                del cache[key]
                del last_update[key]
        
        return None
    
    def set_cache(self, cache_type: str, key: str, value):
        """设置缓存"""
        if cache_type == 'market_data':
            self.market_data_cache[key] = value
            self.last_cache_update['market_data'][key] = time.time()
        elif cache_type == 'strategy_config':
            self.strategy_config_cache[key] = value
            self.last_cache_update['strategy_config'][key] = time.time()
    
    def clear_expired(self):
        """清理过期缓存"""
        current_time = time.time()
        
        # 清理市场数据缓存
        for key in list(self.market_data_cache.keys()):
            if current_time - self.last_cache_update['market_data'].get(key, 0) >= self.cache_ttl['market_data']:
                del self.market_data_cache[key]
                if key in self.last_cache_update['market_data']:
                    del self.last_cache_update['market_data'][key]
        
        # 清理策略配置缓存
        for key in list(self.strategy_config_cache.keys()):
            if current_time - self.last_cache_update['strategy_config'].get(key, 0) >= self.cache_ttl['strategy_config']:
                del self.strategy_config_cache[key]
                if key in self.last_cache_update['strategy_config']:
                    del self.last_cache_update['strategy_config'][key]

cache_manager = CacheManager()

# Redis Connection
try:
    redis_client = redis.from_url(settings.REDIS_URL)
    logger.info("Connected to Redis")
except Exception as e:
    logger.error(f"Failed to connect to Redis: {e}")
    redis_client = None

def handle_signal(signal_data):
    """
    Callback function to handle signals generated by strategies.
    1. Save to Database
    2. Publish to Redis
    """
    logger.info(f"Processing Signal: {signal_data}")
    
    # 1. Save to Database
    db = SessionLocal()
    try:
        signal = Signal(
            strategy_id=signal_data['strategy_id'],
            symbol=signal_data['symbol'],
            side=signal_data['side'],
            price=signal_data['price'],
            reason=signal_data['reason']
        )
        db.add(signal)
        db.commit()
        logger.info(f"Signal saved to DB: ID {signal.id}")
    except Exception as e:
        logger.error(f"Failed to save signal to DB: {e}")
    finally:
        db.close()

    # 2. Publish to Redis
    if redis_client:
        try:
            redis_client.publish('strategy_signals', json.dumps(signal_data))
            logger.info("Signal published to Redis channel 'strategy_signals'")
        except Exception as e:
            logger.error(f"Failed to publish signal to Redis: {e}")

def _start_strategy(s_db, running_strategies):
    try:
        config = json.loads(s_db.config_json)
        
        # Map strategy names to classes
        strategy_classes = {
            'RSI Strategy': RsiStrategy,
            'BTC 5连阴策略': BtcFiveDownStrategy,
            'btc_5down': BtcFiveDownStrategy,
        }
        
        # 获取策略类，默认使用 RsiStrategy
        strategy_class = strategy_classes.get(s_db.name, RsiStrategy)
        
        strategy = strategy_class(
            strategy_id=s_db.id,
            name=s_db.name,
            config=config,
            exchange=exchange_manager,
            signal_callback=handle_signal
        )
        strategy.start()
        running_strategies[s_db.id] = {
            'instance': strategy,
            'config_raw': s_db.config_json
        }
        logger.info(f"Started strategy: {s_db.name} (ID: {s_db.id}) using {strategy_class.__name__}")
    except Exception as e:
        logger.error(f"Failed to start strategy {s_db.name}: {e}", exc_info=True)

def main():
    logger.info("Strategy Engine Starting...")
    # 1. Test Database Connection
    try:
        db = SessionLocal()
        db.execute(text("SELECT 1"))
        logger.info("Database connection successful")
        db.close()
    except Exception as e:
        logger.error(f"Database connection failed: {e}")
        return

    # 2. Test Exchange Connection
    if exchange_manager.exchange:
        logger.info("Exchange connection initialized")
    else:
        logger.warning("Exchange connection failed or not configured")

    running_strategies = {} # {id: {'instance': strategy_obj, 'config_raw': str}}

    # 4. Main Loop
    logger.info("Entering Main Loop...")
    loop_count = 0
    while True:
        loop_count += 1
        
        # 定期清理过期缓存（每 5 分钟清理一次）
        if loop_count % 5 == 0:
            cache_manager.clear_expired()
            logger.info(f"Cache status - Market Data: {len(cache_manager.market_data_cache)}, Strategy Config: {len(cache_manager.strategy_config_cache)}")
        
        # --- Dynamic Strategy Loading ---
        try:
            db = SessionLocal()
            active_db_strategies = db.query(models.Strategy).filter(models.Strategy.is_active == True).all()
            
            active_ids = {s.id for s in active_db_strategies}
            current_ids = set(running_strategies.keys())

            # 1. Stop removed/deactivated strategies
            for s_id in current_ids - active_ids:
                logger.info(f"Strategy {s_id} deactivated or removed. Stopping...")
                running_strategies[s_id]['instance'].stop()
                del running_strategies[s_id]

            # 2. Start new or Update existing strategies
            for s_db in active_db_strategies:
                # Check if new
                if s_db.id not in running_strategies:
                    logger.info(f"Found new strategy: {s_db.name}")
                    _start_strategy(s_db, running_strategies)
                
                # Check if config changed
                elif running_strategies[s_db.id]['config_raw'] != s_db.config_json:
                    logger.info(f"Configuration changed for {s_db.name}. Restarting...")
                    running_strategies[s_db.id]['instance'].stop()
                    _start_strategy(s_db, running_strategies)
                    
        except Exception as e:
            logger.error(f"Error syncing strategies from DB: {e}")
        finally:
            db.close()

        if not running_strategies:
            logger.warning("No active strategies running.")

        # --- Run Logic (Parallel Execution) ---
        # 使用线程池并发执行所有策略，避免单个策略卡住整个引擎
        with ThreadPoolExecutor(max_workers=min(len(running_strategies), 10)) as executor:
            futures = {}
            for strategy_id, s_entry in running_strategies.items():
                future = executor.submit(s_entry['instance'].on_tick)
                futures[future] = strategy_id
            
            # 等待所有策略执行完成（设置超时）
            for future in as_completed(futures, timeout=50):
                strategy_id = futures[future]
                try:
                    future.result()
                except Exception as e:
                    logger.error(f"Error in strategy {strategy_id} tick: {e}")

        time.sleep(60) # Loop every minute

if __name__ == "__main__":
    main()
