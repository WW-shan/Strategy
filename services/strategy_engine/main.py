import time
import logging
import sys
import json
import redis
from database import SessionLocal
from exchange import exchange_manager
from config import settings
from models import Signal
import models
from strategies.rsi_strategy import RsiStrategy

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler(sys.stdout)]
)
logger = logging.getLogger(__name__)

# Redis Connection
try:
    redis_client = redis.from_url(settings.REDIS_URL)
    logger.info("Connected to Redis")
except Exception as e:
    logger.error(f"Failed to connect to Redis: {e}")
    redis_client = None

def handle_signal(signal_data):
    """
    Callback function to handle signals generated by strategies.
    1. Save to Database
    2. Publish to Redis
    """
    logger.info(f"Processing Signal: {signal_data}")
    
    # 1. Save to Database
    db = SessionLocal()
    try:
        signal = Signal(
            strategy_id=signal_data['strategy_id'],
            symbol=signal_data['symbol'],
            side=signal_data['side'],
            price=signal_data['price'],
            reason=signal_data['reason']
        )
        db.add(signal)
        db.commit()
        logger.info(f"Signal saved to DB: ID {signal.id}")
    except Exception as e:
        logger.error(f"Failed to save signal to DB: {e}")
    finally:
        db.close()

    # 2. Publish to Redis
    if redis_client:
        try:
            redis_client.publish('strategy_signals', json.dumps(signal_data))
            logger.info("Signal published to Redis channel 'strategy_signals'")
        except Exception as e:
            logger.error(f"Failed to publish signal to Redis: {e}")

def main():
    logger.info("Strategy Engine Starting...")
    
    # 1. Test Database Connection
    try:
        db = SessionLocal()
        db.execute("SELECT 1")
        logger.info("Database connection successful")
        db.close()
    except Exception as e:
        logger.error(f"Database connection failed: {e}")
        return

    # 2. Test Exchange Connection
    if exchange_manager.exchange:
        logger.info("Exchange connection initialized")
    else:
        logger.warning("Exchange connection failed or not configured")

    # 3. Load Strategies from Database
    active_strategies = []
    
    db = SessionLocal()
    try:
        # Fetch all active strategies
        strategies_db = db.query(models.Strategy).filter(models.Strategy.is_active == True).all()
        logger.info(f"Found {len(strategies_db)} active strategies in database")

        for s in strategies_db:
            try:
                config = json.loads(s.config_json)
                
                # Currently we only support 'RsiStrategy'. 
                # In the future, we can add a 'type' field to the Strategy model to distinguish classes.
                # For now, we assume all strategies are RSI strategies.
                strategy_instance = RsiStrategy(
                    strategy_id=s.id,
                    name=s.name,
                    config=config,
                    exchange=exchange_manager,
                    signal_callback=handle_signal
                )
                strategy_instance.start()
                active_strategies.append(strategy_instance)
                logger.info(f"Loaded strategy: {s.name} (ID: {s.id})")
            except Exception as e:
                logger.error(f"Failed to load strategy {s.name}: {e}")
                
    except Exception as e:
        logger.error(f"Error loading strategies from DB: {e}")
    finally:
        db.close()

    # If no strategies loaded, add a dummy one for testing if needed, or just warn
    if not active_strategies:
        logger.warning("No active strategies loaded from database.")

    # 4. Main Loop
    logger.info("Entering Main Loop...")
    while True:
        # Run logic for all active strategies
        for strategy in active_strategies:
            strategy.on_tick()

        time.sleep(60) # Loop every minute

if __name__ == "__main__":
    main()
